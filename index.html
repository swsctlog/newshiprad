<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Обнаружение лиц в реальном времени</title>
    <!-- Подключаем Tailwind CSS для стилизации -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Дополнительные стили для красивого внешнего вида */
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl bg-gray-800 rounded-2xl shadow-xl p-6 md:p-8 text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-cyan-400 mb-4">Обнаружение лиц</h1>
        <p class="text-gray-400 mb-6">Эта страница использует OpenCV.js для анализа видео с вашей веб-камеры в реальном времени.</p>

        <!-- Контейнер для видео и статуса -->
        <div class="relative w-full aspect-video bg-gray-900 rounded-lg overflow-hidden shadow-inner">
            <!-- Элемент для отображения видео с камеры -->
            <video id="videoInput" class="absolute top-0 left-0 w-full h-full object-cover" playsinline autoplay muted style="transform: scaleX(-1);"></video>
            
            <!-- Canvas, на котором будет отрисовываться результат -->
            <canvas id="canvasOutput" class="absolute top-0 left-0 w-full h-full object-cover" style="transform: scaleX(-1);"></canvas>
            
            <!-- Индикатор статуса и загрузки -->
            <div id="statusContainer" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900 bg-opacity-80 transition-opacity duration-500">
                <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-500 h-12 w-12 mb-4"></div>
                <p id="status" class="text-lg font-medium text-gray-300">Загрузка OpenCV.js...</p>
                <p id="status-details" class="text-sm text-gray-500 mt-1"></p>
            </div>
        </div>
        <div class="mt-4 text-xs text-gray-500">
            <p>Вся обработка происходит в вашем браузере. Данные с камеры никуда не отправляются.</p>
        </div>
    </div>

    <!-- Подключение OpenCV.js -->
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

    <script type="text/javascript">
        // Получаем доступ к HTML элементам
        const video = document.getElementById('videoInput');
        const canvasOutput = document.getElementById('canvasOutput');
        const statusContainer = document.getElementById('statusContainer');
        const statusEl = document.getElementById('status');
        const statusDetailsEl = document.getElementById('status-details');
        const loader = document.getElementById('loader');

        // Функция для обновления статуса на экране
        function updateStatus(text, details = '') {
            statusEl.textContent = text;
            statusDetailsEl.textContent = details;
            console.log(text, details);
        }

        // Эта функция будет вызвана, когда opencv.js загрузится
        async function onOpenCvReady() {
            if (typeof cv === 'undefined' || typeof cv.Mat === 'undefined') {
                setTimeout(onOpenCvReady, 50);
                return;
            }
            updateStatus('OpenCV.js загружен.');
            
            const cascadeFileName = 'haarcascade_frontalface_default.xml';
            const cascadeFileUrl = `https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/${cascadeFileName}`;

            try {
                updateStatus('Загрузка модели для распознавания лиц...', `(файл ${cascadeFileName})`);
                
                const response = await fetch(cascadeFileUrl);
                if (!response.ok) throw new Error(`Ошибка при загрузке модели: ${response.statusText}`);
                const buffer = await response.arrayBuffer();
                const data = new Uint8Array(buffer);
                cv.FS_createDataFile('/', cascadeFileName, data, true, false, false);

                updateStatus('Модель успешно загружена.');
                await startCamera(cascadeFileName);

            } catch (error) {
                console.error(error);
                updateStatus('Ошибка при загрузке модели.', 'Пожалуйста, проверьте консоль для деталей.');
                loader.style.display = 'none';
            }
        }

        async function startCamera(cascadeFileName) {
            try {
                updateStatus('Запрос доступа к камере...');
                console.log("Requesting user media...");
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
                
                console.log("User media stream obtained.");
                updateStatus('Камера найдена, запускаем видео...');

                video.srcObject = stream;
                
                video.addEventListener('canplay', () => {
                    if (window.processingStarted) return;
                    window.processingStarted = true;

                    console.log("Video is ready to play ('canplay' event fired).");
                    updateStatus('Камера активна.');
                    statusContainer.style.opacity = '0';
                    setTimeout(() => statusContainer.style.display = 'none', 500);
                    
                    processVideo(cascadeFileName);
                }, { once: true });

            } catch (error) {
                console.error('Ошибка при доступе к камере:', error);
                let errorMessage = 'Пожалуйста, разрешите доступ в настройках браузера.';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Вы отклонили запрос на доступ к камере.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'Камера не найдена на вашем устройстве.';
                }
                updateStatus('Не удалось получить доступ к камере.', errorMessage);
                loader.style.display = 'none';
            }
        }

        function processVideo(cascadeFileName) {
            // Инициализируем классификатор и VideoCapture один раз
            const faceCascade = new cv.CascadeClassifier();
            faceCascade.load(cascadeFileName);
            const cap = new cv.VideoCapture(video);

            // Объявляем переменные для матриц и других данных
            let src;
            let gray;
            const faces = new cv.RectVector();
            const FPS = 30;
            let lastWidth = 0;
            let lastHeight = 0;

            function detectFaces() {
                const begin = Date.now();
                try {
                    const currentWidth = video.videoWidth;
                    const currentHeight = video.videoHeight;

                    // Ждем, пока у видео появятся стабильные размеры
                    if (currentWidth === 0 || currentHeight === 0) {
                        const delay = 1000 / FPS - (Date.now() - begin);
                        setTimeout(detectFaces, delay > 0 ? delay : 0);
                        return;
                    }

                    // Если размер видео изменился, пересоздаем матрицы
                    if (lastWidth !== currentWidth || lastHeight !== currentHeight) {
                        // Удаляем старые матрицы
                        if (src) src.delete();
                        if (gray) gray.delete();
                        
                        // Обновляем размеры
                        lastWidth = currentWidth;
                        lastHeight = currentHeight;
                        canvasOutput.width = lastWidth;
                        canvasOutput.height = lastHeight;

                        // Создаем матрицы с новыми, правильными размерами
                        src = new cv.Mat(lastHeight, lastWidth, cv.CV_8UC4);
                        gray = new cv.Mat(lastHeight, lastWidth, cv.CV_8UC1);
                        console.log(`Матрицы OpenCV пересозданы: ${lastWidth}x${lastHeight}`);
                    }

                    // Читаем кадр в матрицу `src`
                    cap.read(src);

                    if (src.empty()) {
                        const delay = 1000 / FPS - (Date.now() - begin);
                        setTimeout(detectFaces, delay > 0 ? delay : 0);
                        return;
                    }
                    
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    faceCascade.detectMultiScale(gray, faces, 1.1, 5, 0, new cv.Size(30, 30));
                    
                    for (let i = 0; i < faces.size(); ++i) {
                        const face = faces.get(i);
                        const point1 = new cv.Point(face.x, face.y);
                        const point2 = new cv.Point(face.x + face.width, face.y + face.height);
                        cv.rectangle(src, point1, point2, [0, 255, 0, 255], 2);
                    }
                    
                    cv.imshow('canvasOutput', src);
                    
                    const delay = 1000 / FPS - (Date.now() - begin);
                    setTimeout(detectFaces, delay > 0 ? delay : 0);

                } catch (err) {
                    console.error("Ошибка в цикле обработки:", err);
                    updateStatus('Произошла ошибка.', 'Обновите страницу, чтобы попробовать снова.');
                    // Очищаем ресурсы при фатальной ошибке
                    if (src) src.delete();
                    if (gray) gray.delete();
                    // `cap` не имеет метода delete, поэтому его не удаляем
                    faces.delete();
                    faceCascade.delete();
                }
            }
            detectFaces();
        }
    </script>
</body>
</html>
